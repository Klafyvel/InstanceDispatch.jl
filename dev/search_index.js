var documenterSearchIndex = {"docs":
[{"location":"#InstanceDispatch","page":"Home","title":"InstanceDispatch","text":"Documentation for InstanceDispatch.\n\n","category":"section"},{"location":"#InstanceDispatch.@instancedispatch","page":"Home","title":"InstanceDispatch.@instancedispatch","text":"@instancedispatch myfunction(::T, args...; kwargs...) default=nothing\n\nWrite a specialized function to dispatch on instances values of type T. The only reauirement is that Type{T} has its own method for Base.instances.\n\nYou are allowed to chain dispatching, i.e. dispatching on multiple instancied types. This is done by having Any or Val parameter types prepending the enumeration. See examples.\n\nExamples\n\n@enum GreetEnum Hello Goodbye\nfunction greet(::Val{Hello}, who)\n    return \"Hello \" * who\nend\nfunction greet(::Val{Goodbye}, who)\n    return \"Goodbye \" * who\nend\n@instancedispatch greet(::GreetEnum, who)\n\nThis last line is equivalent to defining the following method:\n\nfunction greet(e::GreetEnum, who)\n    if e == Hello\n        return greet(Val(Hello), who)\n    elseif e == Goodbye\n        return greet(Val(Goodbye), who)\n    else \n        nothing\n    end\nend\n\nYou can also dispatch on multiple enums. In that case, it is advised to explicitely state the types as much as possible.\n\n@enum TitleEnum Citizen Comrade\ntitle(::Val{Citizen}) = \"citizen\"\ntitle(::Val{Comrade}) = \"comrade\"\nfunction greet(::Val{Hello}, t::Val, who)\n    return join([\"Hello\", title(t), who], \" \")\nend\nfunction greet(::Val{Goodbye}, t::Val, who)\n    return join([\"Goodbye\", title(t), who], \" \")\nend\n@instancedispatch greet(::GreetEnum, t::TitleEnum, who)\n@instancedispatch greet(::Val, t::TitleEnum, who)\n\nAll the arguments in the function call given to the macro will be passed in the invocations. In case they are anonymous, new names will be created using gensym. where statements are supported.\n\nwarning: Method availability\nIt is important that there is a method for each instance of your enum, otherwise you might encounter errors, or worse, trigger the ire of JET.jl! It can be useful to define catch-all methods such as:function greet(::Val, _, _)\n    #...\nendThat returns a default value.\n\nIt is possible to use type annotations to help Julia figure out the type of the return value:\n\n@enum GreetEnum Hello Goodbye\nfunction greet(::Val{Hello}, who)\n    return \"Hello \" * who\nend\nfunction greet(::Val{Goodbye}, who)\n    return \"Goodbye \" * who\nend\n@instancedispatch greet(::GreetEnum, who)::String\n\nHowever, this might cause linting errors if the default value given to the macro does not fit this type. You can set the default (although never used) value that  the function will return using the default keyword parameter:\n\n@enum GreetEnum Hello Goodbye\nfunction greet(::Val{Hello}, who)\n    return \"Hello \" * who\nend\nfunction greet(::Val{Goodbye}, who)\n    return \"Goodbye \" * who\nend\n@instancedispatch greet(::GreetEnum, who) default=\"\"\n\n\n\n\n\n","category":"macro"}]
}
